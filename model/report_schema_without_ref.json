{
  "$schema": "http://json-schema.org/draft-04/schema#",
  "id": "http://github.com/Boavizta/ai-power-measures-sharing/blob/feature/hackathon/model/report_schema.json",
  "title": "report",
    "description": "the main object containing all the context pertaining to a computing task",
    "type": "object",
    "properties": {
      "header": {
        "type": "object",
        "description": "information about the source of the report and publishing organization's details",
        "properties": {
          "licensing": {
            "type": "string",
            "description": "the type of licensing applicable for the sharing of the report"
          },
          "formatVersion": {
            "type": "string",
            "description": "the version of the specification of this set of schemas defining the report's fields"
          },
          "formatVersionSpecificationUri": {
            "type": "string",
            "description": "the URI of the present specification of this set of schemas"
          },
          "reportId": {
            "type": "string",
            "description": "the unique identifier of this report, preferably as a uuid4 string"
          },
          "reportDatetime": {
            "type": "string",
            "description": "the publishing date of this report in format YYYY-MM-DD HH:MM:SS"
          },
          "reportStatus": {
            "type": "string",
            "enum": [ "draft", "final", "corrective", "$other" ],
            "description": "the status of this report"
          },
          "publisher": {
            "type": "object",
            "description": "the details about the publishing organization who produced the report",
            "properties": {
              "name": {
                "type": "string",
                "description": "name of the organization"
              },
              "division": {
                "type": "string",
                "description": "name of the publishing department within the organization"
              },
              "projectName": {
                "type": "string",
                "description": "name of the publishing project within the organization"
              },
              "confidentialityLevel": {
                "type": "string",
                "enum": [ "public", "internal", "confidential", "secret" ],
                "description": " the confidentiality of the report"
              },
              "publicKey": {
                "type": "string",
                "description": "the cryptographic public key to check the identity of the publishing organization"
              }
            },
            "required": [
              "confidentialityLevel"
            ]
          }
        },
        "required": [
          "formatVersion",
          "reportId",
          "reportStatus"
        ]
      },
      "task": {
        "type": "object",
        "description": "the nature of the task being measured",
        "properties": {
          "taskType": {
            "type": "string",
            "description": "type of the computing task of machine learning, example : datacreation, preprocessing, supervised_learning, unsupervised_learning, semi_supervised_learning ..."
          },
          "taskFamily": {
            "type": "string",
            "description": "the family of task performed, example : classification, regression, chatbot, summarization, keyword extraction, image recognition..."
          },
          "taskStage": {
            "type": "string",
            "description": "stage of the task, example: training, finetuning, reinforcement, inference, rag..."
          },
          "algorithms": {
            "type": "array",
            "description": "the main algorithmic approache(s) used by the computing task",
            "minItems": 0,
            "maxItems": 10,
            "items": [
              {
                "title": "algorithm",
                "description": "the type of algorithm used by the computing task",
                "type": "object",
                "properties": {
                  "algorithmName": {
                    "type": "string",
                    "description": "the case-sensitive common name of the algorithm, example: random_forest, svm, xgboost..."
                  },
                  "framework": {
                    "type": "string",
                    "description": "the common name of the software framework implementing the algorithm, if any"
                  },
                  "frameworkVersion": {
                    "type": "string",
                    "description": "the version of the software framework implementing the algorithm, if any"
                  },
                  "classPath": {
                    "type": "string",
                    "description": "the full class path of the algorithm within the framework, with elements separated by dots"
                  },
                  "hyperparameters": {
                    "type": "object",
                    "properties": {
                      "tuning_method": {
                        "type": "string",
                        "description": "the method of hyper-parameters tuning used (if any), example : grid_search, randomized_search..."
                      },
                      "values":{
                        "type":"array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "hyperparameterName": {
                              "type": "string",
                              "description": "the name of the hyperparameter, example : c, kernel, gamma, class_weight..."
                            },
                            "hyperparameterValue": {
                              "type": "string",
                              "description": "the value of the hyperparameter, example : rbf, 1e-4, 10, linear..."
                            }
                          }
                        }
                      }
                    }
                  },
                  "quantization": {
                    "type": "number",
                    "description": "the data weights (in bits) obtained thanks to the quantization, example : 2, 8, 16..."
                  }
                },
                "required": [
                  "algorithmName"
                ]
              }
            ]
          },
          "dataset": {
            "type": "array",
            "description": "the list of dataset processed by the computing task",
            "minItems": 1,
            "items": {
              "type":"object",
              "title": "dataset",
              "description": "Describe the nature, shape, number of items and other properties of the dataset involved in your task. If you are performing inferences, please indicate the average size of the data sent for a single inference and fill in the number of inferences in the propertiy: inferenceProperties",
              "properties": {
                "dataType":{
                  "type": "string",
                  "enum": [ "tabular", "audio", "boolean", "image", "video", "object", "text", "$other" ],
                  "description": "the nature of the data, purposedly limited to basic types"
                },
                "fileType": {
                  "type": "string",
                  "enum": [ "3gp", "3gpp", "3gpp2", "8svx", "aa", "aac", "aax", "act", "afdesign", "afphoto", "ai", "aiff", "alac", "amr", "amv", "ape", "arrow", "asf", "au", "avi", "avif", "awb", "bmp", "bpg", "cd5", "cda", "cdr", "cgm", "clip", "cpt", "csv", "deep", "dirac", "divx", "drawingml", "drw", "dss", "dvf", "ecw", "eps", "fits", "flac", "flif", "flv", "flvf4v", "gem", "gerber", "gif", "gle", "gsm", "heif", "hp-gl", "html", "hvif", "ico", "iklax", "ilbm", "img", "ivs", "jpeg", "json", "kra", "lottie", "m4a", "m4b", "m4p", "m4v", "mathml", "matroska", "mdp", "mmf", "movpkg", "mp3", "mpc", "mpeg1", "mpeg2", "mpeg4", "msv", "mxf", "naplps", "netpbm", "nmf", "nrrd", "nsv", "odg", "ods", "ogg", "opus", "pam", "parquet", "pbm", "pcx", "pdf", "pdn", "pgf", "pgm", "pgml", "pict", "plbm", "png", "pnm", "postscript", "ppm", "psd", "psp", "pstricks", "qcc", "quicktime", "ra", "raw", "realmedia", "regis", "rf64", "roq", "sai", "sgi", "sid", "sql", "sln", "svg", "svi", "swf", "text", "tga", "tiff", "tinyvg", "tta", "vicar", "vivoactive", "vml", "vob", "voc", "vox", "wav", "webm", "webp", "wma", "wmf", "wmv", "wv", "xaml", "xar", "xcf", "xisf", "xls", "xlsx", "xml", "xps", "yaml", "$other", null ],
                  "description": "the file type of the dataset"
                },
                "volume": {
                  "type": "integer",
                  "description": "the size of the dataset"
                },
                "volumeUnit": {
                  "type": "string",
                  "enum": [ "kilobyte", "megabyte", "gigabyte", "terabyte", "petabyte", "exabyte", "zettabyte", "yottabyte" ],
                  "description": "the unit of the size of the dataset"
                },
                "items": {
                  "type": "integer",
                  "description": "the number of items in the dataset"
                },
                "shape": {
                  "type": "array",
                  "description": "the shape of each dataset item (for instance, an array of size 3, for greyscale images)",
                  "items": {
                    "type": "integer"
                  }
                },
                "inferenceProperties": {
                  "type": "array",
                  "description": "if you are describing an inference, please describe the type of query(s) sent to the model",
                  "items": {
                    "type":"object",
                    "title": "query",
                    "description": "the type of query send to the algorithm",
                    "properties": {
                      "nbRequest": {
                        "type": "number",
                        "description": "for how many request is your measure ? for example 100 prompts or 100 images"
                      },
                      "parametersNLP":{
                        "type": "object",
                        "description": "if you are using inference on a NLP task, please fill these properties",
                        "properties": {
                          "nbTokensInput":{
                            "type": "number",
                            "description": "the number of tokens in the input"
                          },
                          "nbWordsInput":{
                            "type": "number",
                            "description": "the number of words in the input"
                          },
                          "nbTokensOutput":{
                            "type": "number",
                            "description": "the number of tokens in the response"
                          },
                          "nbWordsOutput":{
                            "type": "number",
                            "description": "the number of words in the response"
                          },
                          "contextWindowsSize":{
                            "type":"number",
                            "description": "the number of tokens your system keeps in memory to generate the next answer"
                          },
                          "cache":{
                            "type": "boolean",
                            "description": "Does your chatbot have a cache ? If yes then true, else false"
                          }
                        }
                      }
                    },
                    "required": [
                      "nbRequest"
                    ]

                  }
                },
                "source": {
                  "type": "string",
                  "enum": [ "public", "private", "$other" ],
                  "description": "the kind of source of the dataset"
                },
                "sourceUri": {
                  "type": "string",
                  "description": "the URI of the dataset if available"
                },
                "owner": {
                  "type": "string",
                  "description": "the owner of the dataset if available"
                }
              },
              "required": [
                "dataType",
                "volume",
                "volumeUnit"
              ]
            }
          },
          "measuredAccuracy": {
            "type": "number",
            "minimum": 0,
            "maximum": 1,
            "description": "the measured accuracy of your model (between 0 and 1)"
          },
          "estimatedAccuracy": {
            "type": "string",
            "enum": [ "very_poor", "poor", "average", "good", "very_good" ],
            "description": "if you didn't measure the accuracy of your model in concrete percentages, you can give an assessment of the precision between: VERY POOR, POOR, AVERAGE, GOOD, VERY GOOD"
          }
        },
        "required": [
          "taskType",
          "taskFamily",
          "taskStage",
          "algorithms",
          "dataset"
        ]
      },
      "measures": {
        "type": "array",
        "description": "the software and/or hardware measures of the computing task",
        "minItems": 1,
        "items": {
          "type":"object",
          "title": "measure",
          "description": "the energy measure obtained from software and/or hardware tools, for a computing task",
          "properties": {
            "measurementMethod": {
              "type": "string",
              "description": "the method used to perform the energy or FLOPS measure, example: codecarbon, carbonai, flops_compute, wattmeter..."
            },
            "manufacturer": {
              "type": "string",
              "description": "the builder of the measuring tool, if the measurement method is wattmeter"
            },
            "version": {
              "type": "string",
              "description": "the version of the measuring tool, if any"
            },
            "cpuTrackingMode": {
              "type": "string",
              "description": "the method used to track the consumption of the CPU, example : constant, rapl..."
            },
            "gpuTrackingMode": {
              "type": "string",
              "description": "the method used to track the consumption of the GPU, example : constant, nvml..."
            },
            "averageUtilizationCpu": {
              "type":"number",
              "minimum": 0,
              "maximum": 1,
              "description": "the average percentage of use of the cpu during the task, for example: 0.5 if your CPU load was 50% on average."
            },
            "averageUtilizationGpu": {
              "type":"number",
              "minimum": 0,
              "maximum": 1,
              "description": "the average percentage of use of the gpu during the task, for example: 0.8 if your GPU load was 80% on average."
            },
            "serverSideInference":{
              "type": "string",
              "enum": [ "ai_server", "inference_server", "both" ],
              "description": "if you practice inference through an API, do you estimate the consumption of the AI server alone ? (because the AI is deployed on your own server and you have access to the measurement, or because you have estimated it with a tool like EcoLogits). Or do you estimate the consumption from the inference_server side or from both side at the same time ?"
            },
            "unit": {
              "type": "string",
              "enum": [ "mWh","Wh", "kWh", "MWh", "GWh", "kJoule", "MJoule", "GJoule", "TJoule", "PJoule", "BTU", "kiloFLOPS", "megaFLOPS", "gigaFLOPS", "teraFLOPS", "petaFLOPS", "exaFLOPS", "zettaFLOPS", "yottaFLOPS" ],
              "description": "the unit of the power consumption measure of the computing task"
            },
            "powerCalibrationMeasurement": {
              "type": "number",
              "description": "the power consumed during your calibration measure if any (to isolate the inital consumption of your machine)"
            },
            "durationCalibrationMeasurement": {
              "type": "number",
              "description": "the duration of your calibration if any (in seconds)"
            },
            "powerConsumption": {
              "type": "number",
              "description": "the power consumption measure of the computing task"
            },
            "measurementDuration": {
              "type": "number",
              "description": "the measurement's duration (in seconds)"
            },
            "measurementDateTime": {
              "type": "string",
              "description": "the date on which the measurement began, in format YYYY-MM-DD HH:MM:SS"
            }
          },
          "required": [
            "measurementMethod",
            "unit",
            "powerConsumption"
          ]
        },
        "required": [
          "measures"  
        ]
      },
      "system": {
        "type": "object",
        "description": "system information of the infrastructure on which is run the computing task",
        "properties": {
          "os": {
            "type": "string",
            "description":"name of the operating system"
          },
          "distribution": {
            "type": "string",
            "description":"distribution of the operating system"
          },
          "distributionVersion": {
            "type": "string",
            "description":"distribution's version of the operating system"
          }
        },
        "required": [
          "os"
        ]
      },
      "software": {
        "type": "object",
        "description": "programming language information of the computing task",
        "properties": {
          "language": {
            "type": "string",
            "description": "name of the programming language used, example : c, java, julia, python..."
          },
          "version": {
            "type": "string",
            "description": "version of the programming language used"
          }
        },
        "required": [
          "language"
        ]
      },
      "infrastructure": {
        "type": "object",
        "description": "the infrastructure on which is performed the computing task",
        "properties": {
        "infraType":{
          "type":"string",
          "enum":["public_cloud","private_cloud", "on_premise", "$other"],
          "description": "the type of infrastructure used for the task"
        },
        "cloudProvider":{
          "type":"string",
          "description": "If you are on the cloud, the name of your cloud provider, for example : aws, azure, google, ovh..."
        },
        "cloudInstance":{
          "type":"string",
          "description": "If you are on the cloud, the name of your cloud instance, for example : a1.large, dasv4-type2..."
        },
        "components": {
          "type": "array",
          "minItems": 1,
          "items": {
            "type": "object",
            "title": "hardware",
            "description": "a hardware subsystem part of the infrastructure running the computing task",
            "properties": {
              "componentName": {
                "type": "string",
                "description": "the type of this subsystem part of your infrastructure, example: cpu, gpu, hdd, sdd..."
              },
              "nbComponent": {
                "type": "integer",
                "description": "the number of this component in your infrastructure"
              },
              "memorySize": {
                "type":"integer",
                "description": "the size of the memory of the component in Go"
              },
              "manufacturer": {
                "type": "string",
                "description": "the name of the manufacturer, example: nvidia"
              },
              "family": {
                "type": "string",
                "description": "the family of this component, example: geforce"
              },
              "series": {
                "type": "string",
                "description": "the series of this component, example: rtx_4080"
              },
              "share": {
                "type": "number",
                "minimum": 0,
                "maximum": 1,
                "description": "the percentage of the physical equipment which is assigned to you"
              }
            },
            "required": [
              "componentName",
              "nbComponent"
            ]
          }
        }
        },
        "required": [
          "infraType",
          "components"
        ]
      },
      "environment": {
        "type": "object",
        "description": "environment of the infrastructure: region of calculation and energy used",
        "properties": {
          "country": {
            "type": "string"
          },
          "latitude": {
            "type": "number"
          },
          "longitude": {
            "type": "number"
          },
          "location": {
            "type": "string"
          },
          "powerSupplierType": {
            "type": "string",
            "enum": [ "public", "private", "internal", "$other" ]
          },
          "powerSource": {
            "type": "string",
            "enum": [ "solar", "wind", "nuclear", "hydroelectric", "gas", "coal", "$other" ]
          },
          "powerSourceCarbonIntensity": {
            "type": "number",
            "description": "Carbon intensity of the electicity you used (in gCO2eq/kWh)"
          }
        },
        "required": [
          "country"
        ]
      },
      "quality": {
        "type": "string",
        "enum":[ "high", "medium", "low" ],
        "description": "the quality of the information you provided, 3 possibilities : high (percentage error +/-10%), medium (percentage error +/-25%), low (percentage error +/-50%)"
      },
      "$hash": {
        "type": "object",
        "properties": {
          "hashAlgorithm": {
            "type": "string",
            "enum": [ "MD5", "RIPEMD-128", "RIPEMD-160", "RIPEMD-256", "RIPEMD-320", "SHA-1", "SHA-224", "SHA-256", "SHA-384", "SHA-512" ],
            "description": "the hash function to apply first to the JSON report"
          },
          "cryptographicAlgorithm": {
            "type": "string",
            "enum": [ "RSA", "DSA", "ECDSA", "EDDSA" ],
            "description": "the public key function to apply to the hash"
          },
          "value": {
            "type": "string",
            "description": "encrypted value of the hash value of the minimized JSON instance string, using the publisher's private key and including all root properties except the $hash property itself"
          }
        },
        "required": [
          "hashAlgorithm",
          "cryptographicAlgorithm",
          "value"
        ]
      }
    },
    "required": [
      "task",
      "measures",
      "infrastructure",
      "environment"
    ]
  }
