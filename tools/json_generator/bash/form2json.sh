#!/bin/bash

##########################################
# Script for converting a form generated by gen_form.sh into a json at Boamps data model format
# Author : dfovet
# Version : 0.87
# Date : 20250717
##########################################

##########################################
# Usage
##########################################
usage()
{
echo "-----------------------------------------------------"
echo "Wrong Usage WARNING"
echo "-----------------------------------------------------"
echo "Purpose of the script : Convert a form generated by gen_form.sh into json at Boamps data model format"
echo ""
echo "Command structure: "
echo "./form2json.sh <Generation Type> <Reference CSV> <Form file to convert>"
echo "exemple: ./form2json.sh -a Ref_CodeCarbon.csv report1.txt > json_example.json"
echo "<Generation Type>"
echo " -a for ALL generates a json including mandatory and optional fields"
echo "<Reference CSV>"
echo "Descriptive file of the data model including or not the references to fill the form from a CSV"
echo "Example: Ref_CodeCarbon.csv To pre-fill the form from a CodeCarbon csv"
}

##########################################
# Log Management
##########################################
tolog()
{
LOGTIMETAG=`date +%Y\;%m\;%d\;%H\;%M\;%S\;%N`
echo "$LOGTIMETAG--$1" >> $2
echo "$LOGTIMETAG--$1"
}

tolognodate()
{
LOGTIMETAG=`date +%Y\;%m\;%d\;%H\;%M\;%S\;%N`
echo "$1" >> $2
echo "$LOGTIMETAG--$1"
}

##########################################
# Read from a file table separated by ;
##########################################
readtab()
{
    i=$2
    j=$3
    RES=""
    RES=$(sed -n ''$j','$j' p' $1 | awk -v idx=$i -F';' '{print $idx}')
    echo "$RES"
}

##########################################
# Read a string in the form between = and # and trimming spaces before and after
##########################################
readlineval()
{
    j=$2
    RES=""
    #echo "<some text>=someuser@somedomain.com #<some text>" | sed 's/.*=\(.*\)#.*/\1/'
    RES=$(sed -n ''$j','$j' p' $1 | sed 's/.*=\(.*\)#.*/\1/' | sed 's/^ *//;s/ *$//')
    echo "$RES"
}


##########################################
# Write identation for the json output file
##########################################
indentification()
{
    j=0
    tot=$1
    if [[ $tot != 0 ]]
    then
        for (( j=1; j<=$tot; j++ ))
        do
            echo -ne "\t"
        done
    fi
}

##########################################
# Init variables
##########################################
DATETAG=`date +%y%m%d-%H%M`
BASEDIR=$(pwd)
BASENAME0=$(basename "$0")
LOGDIR="$BASEDIR/Log"
NPARAMS=3
LOGFILE="$LOGDIR/$BASENAME0_$2_$DATETAG.log"
RESULTFILE="$LOGDIR/Result_$BASENAME0_$2_$DATETAG.log"
ficRef=$2
ficForm=$3
nbligneparam=$(wc -l < $ficRef)
nbtab=0
nbtable=0
nbentry=1
idreadline=10
refline=2
indent=0
endline=""
tableList=();
reflineList=();
refList=();


##########################################
## Check the number of params
##########################################
if [[ $# -lt "$NPARAMS" || $# -gt "$NPARAMS" ]]
   then
       echo "ce script a besoin de $NPARAMS arguments en entree!"
       usage
exit 0
fi

##########################################
## Select execution mode
##########################################
case $1 in 
	"-a")
		mode="A"
		;;
	"-m")
		mode="M"
		;;
	*)
		echo "BAD Argument : $1"
        usage
        exit 0
esac

##########################################
## Retrieve generation params based on info from the form file to convert
##########################################
nbAlgo=$(readlineval $ficForm 2)
nbAlgoHyperparamVal=$(readlineval $ficForm 3)
nbDataset=$(readlineval $ficForm 4)
nbDatasetShape=$(readlineval $ficForm 5)
datasetInferenceProperties=$(readlineval $ficForm 6)
nbMeasures=$(readlineval $ficForm 7)
infraComponents=$(readlineval $ficForm 8)

##########################################
## Writing the start of the json file
##########################################

echo "{"
let "indent++"

##########################################
# We go through the reference table and build for each line the correct json lines
##########################################
for (( refline=2; refline<=$nbligneparam; refline++ ))
do
    #On recupere les informations de la ligne du tableau de reference
    strName=$(readtab $ficRef 4 $refline)
    strType=$(readtab $ficRef 6 $refline)
    strMandatory=$(readtab $ficRef 7 $refline)
    strNextType=$(readtab $ficRef 6 $((refline + 1)))

    #Ici on teente de gerer le cote mandatory mais pas completement testÃ© dans cette version
    if [[ "$strMandatory" == "TRUE" ]] 
    then       
        strMandatory="MANDATORY"
    else
        strMandatory="OPTIONAL"
    fi

    #On set les characteres de fin de ligne au mieux par rapport au type suivant (changemetn d'objet ou de table
    if [[ "$strNextType" != "ObjectEnd" ]] && [[ "$strNextType" != "TableEnd" ]] && [[ "$strNextType" != "" ]]
    then
        #echo "Debug : in"
        endline=","
    else
        endline=""
    fi

    #ici on prend en compte si les champt suivant sont vide pour corriger el charactere de fin de ligne cela fonctionne aussi pour les objects et les tables
    array=("Integer${IFS}Enum${IFS}values End${IFS}String${IFS}Integer${IFS}Float${IFS}Boolean${IFS}ObjectEnd${IFS}TableEnd")
    isInArray="$strType"

    if [[ "${IFS}${array[*]}${IFS}" =~ "${IFS}${isInArray}${IFS}" ]] && [[ $strNextType != "DocumentEnd" ]]
    then
      dim=1
      videsuiv=1
      while [[ $videsuiv -eq 1 ]]
      do
        if [[ $(readlineval $ficForm $((idreadline + $dim))) == "" ]]
        then
          if [[ $(readtab $ficRef 6 $((refline + $dim + 1))) == "TableEnd" ]] || [[ $(readtab $ficRef 6 $((refline + $dim + 1))) == "ObjectEnd" ]] || [[ $(readtab $ficRef 6 $((refline + $dim + 1))) == "DocumentEnd" ]]
          then
            endline=""
            videsuiv=0
          fi
          let "dim++"
        else
          videsuiv=0
        fi
      done
    else
      endline=""
    fi

    case $strType in
            
        "Object")
            indentification $indent
            echo "\"$strName\": {"
            let "indent++"
            ;;

        "Enum")
            value=$(readlineval $ficForm $idreadline)
            if [[ $value != "" ]]
            then
              indentification $indent
              echo "\"$strName\":\"$value\"$endline"
            fi
            ;;
            
        "String")
            value=$(readlineval $ficForm $idreadline)
            if [[ $value != "" ]]
            then
              indentification $indent
              echo "\"$strName\":\"$value\"$endline"
            fi
            ;;
            
        "Integer")
            value=$(readlineval $ficForm $idreadline)
            if [[ $value != "" ]]
            then
              indentification $indent
              echo "\"$strName\":$value$endline"
            fi

            ;;

        "Float")
            value=$(readlineval $ficForm $idreadline)
            if [[ $value != "" ]]
            then
              indentification $indent
              echo "\"$strName\":$value$endline"
            fi
            ;;

        "Boolean")
            value=$(readlineval $ficForm $idreadline)
            if [[ $value != "" ]]
            then
              indentification $indent
              echo "\"$strName\":\"$value\"$endline"
            fi
            ;;

        "Table")     
            if [[ $nbtable -ne 0 ]]
            then
                if [[ ${tableList[$((nbtable-1))]} != "$strName" ]]
                then
                    tableList[$nbtable]="$strName"
                    reflineList[$nbtable]="$refline"
                    refList[$nbtable]=1
                    nbentry=1
                    
                    let "nbtable++"
                    echo "$(indentification $indent)\"$strName\": ["
                    let "indent++"
                    echo "$(indentification $indent){"

                fi
            else
                tableList[$nbtable]="$strName"
                reflineList[$nbtable]="$refline"
                refList[$nbtable]=1

                let "nbtable++"
                echo "$(indentification $indent)\"$strName\": ["
                let "indent++"
                echo "$(indentification $indent){"

            fi
            
            let "nbtab++" 

            ;;
       
        "TableEnd")
            
            array=("header End${IFS}task End${IFS}values End${IFS}shape End${IFS}inferenceProperties End${IFS}components End${IFS}algorithms End${IFS}dataset End${IFS}measures End${IFS}system End${IFS}software End${IFS}infrastructure End${IFS}environment End${IFS}\$hash End")
            isInArray="$strName"

            if [[ "${IFS}${array[*]}${IFS}" =~ "${IFS}${isInArray}${IFS}" ]]; then
                if [ $nbtab -gt 0 ]; then let "nbtab--" ; fi
            fi
            
            tableList=(${tableList[@]:0:$nbtable} ${tableList[@]:$(($nbtable + 1))})

            if [[ $strName == "algorithms End" ]]; then nbIter=$nbAlgo ; fi
            if [[ $strName == "values End" ]]; then nbIter=$nbAlgoHyperparamVal ; fi
            if [[ $strName == "shape End" ]]; then nbIter=$nbDatasetShape ; fi
            if [[ $strName == "inferenceProperties End" ]]; then nbIter=$datasetInferenceProperties ; fi
            if [[ $strName == "components End" ]]; then nbIter=$infraComponents ; fi
            if [[ $strName == "dataset End" ]]; then nbIter=$nbDataset ; fi
            if [[ $strName == "measures End" ]]; then nbIter=$nbMeasures ; fi

            if [[ ${refList[$((nbtable-1))]} < $nbIter ]]; then
                refList[$((nbtable-1))]=$((refList[$((nbtable-1))] + 1))
                nbentry=${refList[$((nbtable-1))]}
                refline=$((reflineList[$((nbtable-1))] - 1))

                #echo "$(indentification $indent)}$endline"
                echo "$(indentification $indent)},"
                echo "$(indentification $indent){"

            else
                let "nbtable--"
                refList=(${refList[@]:0:$nbtable} ${refList[@]:$(($nbtable + 1))})
                tableList=(${tableList[@]:0:$nbtable} ${tableList[@]:$(($nbtable + 1))})
                reflineList=(${reflineList[@]:0:$nbtable} ${reflineList[@]:$(($nbtable + 1))})
                nbentry=1

                echo "$(indentification $indent)}"
                let "indent--"  
                echo "$(indentification $indent)]$endline"

            fi  
            
            ;;
       
        "ObjectEnd")
            array=("header End${IFS}task End${IFS}measures End${IFS}system End${IFS}software End${IFS}infrastructure End${IFS}environment End${IFS}\$hash End")
            isInArray="$strName"

            if [[ "${IFS}${array[*]}${IFS}" =~ "${IFS}${isInArray}${IFS}" ]]; then 
                if [ $nbtab -gt 0 ]; then let "nbtab--" ; fi
            fi

            echo "$(indentification $indent)}$endline"
            let "indent--"

            ;;

    esac

    IFS="|"

    value=""
    let "idreadline++"

    done

#########################################
# Finalisation of the json file
##########################################
echo "}"